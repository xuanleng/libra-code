

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>libra_py.workflows.nbra.step3 &mdash; Libra 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Libra
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/libra_py.html">libra_py</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Libra</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>libra_py.workflows.nbra.step3</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for libra_py.workflows.nbra.step3</h1><div class="highlight"><pre>
<span></span><span class="c1">#*********************************************************************************</span>
<span class="c1">#* Copyright (C) 2017-2019 Brendan A. Smith, Wei Li, Alexey V. Akimov</span>
<span class="c1">#*</span>
<span class="c1">#* This file is distributed under the terms of the GNU General Public License</span>
<span class="c1">#* as published by the Free Software Foundation, either version 2 of</span>
<span class="c1">#* the License, or (at your option) any later version.</span>
<span class="c1">#* See the file LICENSE in the root directory of this distribution</span>
<span class="c1">#* or &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#*</span>
<span class="c1">#*********************************************************************************/</span>
<span class="c1">#</span>
<span class="c1">#  </span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: step3</span>
<span class="sd">   :platform: Unix, Windows</span>
<span class="sd">   :synopsis: This module is designed to convert the results of QE calculations </span>
<span class="sd">       (KS orbital energies and time-overlaps in the KS basis) to the generic Hvib</span>
<span class="sd">       matrices, which account for:</span>

<span class="sd">           - state reordering;</span>
<span class="sd">           - phase corrections;</span>
<span class="sd">           - multi-electron wavefunction (Slater determinants) and spin-adaptation</span>
<span class="sd">           - scissor operator corrections to energy levels</span>

<span class="sd">.. moduleauthor:: Brendan A. Smith, Wei Li, and Alexey V. Akimov</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">cmath</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">==</span><span class="s2">&quot;cygwin&quot;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">cyglibra_core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">==</span><span class="s2">&quot;linux&quot;</span> <span class="ow">or</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span><span class="o">==</span><span class="s2">&quot;linux2&quot;</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">liblibra_core</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">mapping</span>
<span class="kn">import</span> <span class="nn">util.libutil</span> <span class="k">as</span> <span class="nn">comn</span>
<span class="kn">import</span> <span class="nn">libra_py.tsh</span> <span class="k">as</span> <span class="nn">tsh</span>
<span class="kn">import</span> <span class="nn">libra_py.units</span> <span class="k">as</span> <span class="nn">units</span>
<span class="kn">import</span> <span class="nn">libra_py.hungarian</span> <span class="k">as</span> <span class="nn">hungarian</span>



<div class="viewcode-block" id="get_Lowdin"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.get_Lowdin">[docs]</a><span class="k">def</span> <span class="nf">get_Lowdin</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;  </span>
<span class="sd">    Find the S_i_half for the S matrix - alpha and beta components</span>

<span class="sd">    Args: </span>
<span class="sd">        S ( CMATRIX(2N, 2N) ): is a matrix of MO overlaps. It has a block structure as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                S = </span>
<span class="sd">                \\begin{vmatrix}</span>
<span class="sd">                S_{aa}  &amp; S_{ab} \\\</span>
<span class="sd">                S_{ba}  &amp; S_{bb}</span>
<span class="sd">                \\end{vmatrix}</span>

<span class="sd">            Here, S_xy are the overlaps of the MOs for spin channels x and y (alpha, beta) - only</span>
<span class="sd">            spatial components of the orbitals are taken into account here.</span>
<span class="sd">            Here, N - is the total number of orbitals (double occupancies)        </span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (S_aa_i_half, S_bb_i_half), where:</span>

<span class="sd">            * S_aa_i_half ( CMATRIX(N,N) ): S_aa^{-1/2} - inverse square root matrix for the alpha-alpha block</span>
<span class="sd">            * S_bb_i_half ( CMATRIX(N,N) ): S_bb^{-1/2} - inverse square root matrix for the beta-beta block</span>
<span class="sd">          </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">num_of_cols</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># division by 2 because it is a super-matrix</span>

    <span class="n">alp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">))</span>
    <span class="n">bet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nstates</span><span class="p">))</span>

    <span class="n">S_aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>
    <span class="n">S_bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>

    <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
    <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>

    <span class="n">is_inv</span> <span class="o">=</span> <span class="n">FullPivLU_rank_invertible</span><span class="p">(</span><span class="n">S_aa</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error, S_aa is not invertible, Exiting Program&quot;</span><span class="p">);</span>  <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">is_inv</span> <span class="o">=</span> <span class="n">FullPivLU_rank_invertible</span><span class="p">(</span><span class="n">S_bb</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_inv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error, S_bb is not invertible, Exiting Program&quot;</span><span class="p">);</span>  <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">S_aa_half</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">)</span>
    <span class="n">S_aa_i_half</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">)</span>
    <span class="n">sqrt_matrix</span><span class="p">(</span><span class="n">S_aa</span><span class="p">,</span> <span class="n">S_aa_half</span><span class="p">,</span> <span class="n">S_aa_i_half</span><span class="p">)</span>

    <span class="n">S_bb_half</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">)</span>
    <span class="n">S_bb_i_half</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">)</span>
    <span class="n">sqrt_matrix</span><span class="p">(</span><span class="n">S_bb</span><span class="p">,</span> <span class="n">S_bb_half</span><span class="p">,</span> <span class="n">S_bb_i_half</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">S_aa_i_half</span><span class="p">,</span> <span class="n">S_bb_i_half</span></div>




<div class="viewcode-block" id="apply_normalization"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.apply_normalization">[docs]</a><span class="k">def</span> <span class="nf">apply_normalization</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">St</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Transforms the input transition density matrix computed with potentially</span>
<span class="sd">    non-orthogonalized orbitals such that it would correspond to the properly</span>
<span class="sd">    orthonormalized ones</span>

<span class="sd">    Args: </span>
<span class="sd">        S ( CMATRIX(2N, 2N) ): is a matrix of MO overlaps S_ij = &lt;i|j&gt;. It has a block structure as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                S = </span>
<span class="sd">                \\begin{vmatrix}</span>
<span class="sd">                S_{aa}  &amp; S_{ab} \\\</span>
<span class="sd">                S_{ba}  &amp; S_{bb}</span>
<span class="sd">                \\end{vmatrix}</span>

<span class="sd">            Here, S_xy are the overlaps of the MOs for spin channels x and y (alpha, beta) - only</span>
<span class="sd">            spatial components of the orbitals are taken into account here.</span>
<span class="sd">            Here, N - is the total number of orbitals (double occupancies)        </span>

<span class="sd">        St ( CMATRIX(2N, 2N) ): the transition density matrix St_ij = &lt;i|d/dt|j&gt;. It has a block structure as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                St = </span>
<span class="sd">                \\begin{vmatrix}</span>
<span class="sd">                St_{aa}  &amp; St_{ab} \\\</span>
<span class="sd">                St_{ba}  &amp; St_{bb}</span>
<span class="sd">                \\end{vmatrix}</span>

<span class="sd">            Here, St_xy are the transition density matrix for spin channels x and y (alpha, beta) - only</span>
<span class="sd">            spatial components of the orbitals are taken into account here.</span>
<span class="sd">            Here, N - is the total number of orbitals (double occupancies)        </span>

<span class="sd">    Returns:</span>
<span class="sd">        None: but the input matrix ```St``` is changed</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">St</span><span class="p">)</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># division by 2 because it is a super-matrix</span>
    
    <span class="n">alp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">))</span>
    <span class="n">bet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nstates</span><span class="p">))</span>

    <span class="n">St_aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">);</span>  <span class="n">St_ab</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">);</span>
    <span class="n">St_ba</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">);</span>  <span class="n">St_bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="n">nstates</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    
        <span class="n">U1_a</span><span class="p">,</span> <span class="n">U1_b</span> <span class="o">=</span> <span class="n">get_Lowdin</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>    <span class="c1"># time n</span>
        <span class="n">U2_a</span><span class="p">,</span> <span class="n">U2_b</span> <span class="o">=</span> <span class="n">get_Lowdin</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># time n+1          </span>
    
        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>    <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>    <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
    
        <span class="n">St_aa</span> <span class="o">=</span> <span class="n">U1_a</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">St_aa</span> <span class="o">*</span> <span class="n">U2_a</span>
        <span class="n">St_ab</span> <span class="o">=</span> <span class="n">U1_a</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">St_ab</span> <span class="o">*</span> <span class="n">U2_b</span>
        <span class="n">St_ba</span> <span class="o">=</span> <span class="n">U1_b</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">St_ba</span> <span class="o">*</span> <span class="n">U2_a</span>
        <span class="n">St_bb</span> <span class="o">=</span> <span class="n">U1_b</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">St_bb</span> <span class="o">*</span> <span class="n">U2_b</span>
    
        <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>   <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
        <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>   <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span></div>


        
         
<div class="viewcode-block" id="make_cost_mat"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.make_cost_mat">[docs]</a><span class="k">def</span> <span class="nf">make_cost_mat</span><span class="p">(</span><span class="n">orb_mat_inp</span><span class="p">,</span> <span class="n">en_mat_inp</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Makes the cost matrix from a given TDM and information on states&#39; energies</span>

<span class="sd">    Args:    </span>
<span class="sd">        orb_mat_inp  ( CMATRIX(nstates,nstates) or MATRIX(nstates,nstate) ): the transition density matrix</span>
<span class="sd">            TDM in a given basis. Here, ```nstates``` - the number of states (e.g. the number of doubly-occupied</span>
<span class="sd">            orbitals )</span>

<span class="sd">        en_mat_inp ( MATRIX(nstates, nstates) ): Matrix of energies in a given basis [units: a.u.]</span>

<span class="sd">        alpha ( float ): Parameter controlling the range of the orbitals that can participate in</span>
<span class="sd">            the reordering. Setting is to 0 makes all orbitals be considered for reordering</span>
<span class="sd">            Setting it to a large number makes the effective number of orbitals participating</span>
<span class="sd">            in the reordering smaller - this can be used to turn off the reordering. [units: a.u.^-1]</span>

<span class="sd">    Returns: </span>
<span class="sd">        MATRIX(nstates, nstates): the matrix of the cost values for different pairs of states</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nstates</span> <span class="o">=</span> <span class="n">orb_mat_inp</span><span class="o">.</span><span class="n">num_of_cols</span>
    <span class="n">cost_mat</span> <span class="o">=</span> <span class="n">MATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>

            <span class="n">s</span> <span class="o">=</span> <span class="n">orb_mat_inp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">*</span><span class="n">s</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span><span class="o">.</span><span class="n">real</span>
            <span class="n">dE</span> <span class="o">=</span> <span class="p">(</span><span class="n">en_mat_inp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">en_mat_inp</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">s2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">dE</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">cost_mat</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cost_mat</span></div>



<div class="viewcode-block" id="apply_state_reordering"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.apply_state_reordering">[docs]</a><span class="k">def</span> <span class="nf">apply_state_reordering</span><span class="p">(</span><span class="n">St</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Performs the state&#39;s identity reordering in a given basis for all time steps.</span>
<span class="sd">    This is reflects in the corresponding changess of the TDM.</span>

<span class="sd">    Args:</span>
<span class="sd">        St ( list of CMATRIX(nstates, nstates) ): TDM for each timestep</span>
<span class="sd">        E ( list of CMATRIX(nstates, nstates) ): energies of all states at every step</span>
<span class="sd">        params ( dictionary ): parameters controlling the reordering</span>
<span class="sd">            * **params[&quot;do_state_reordering&quot;]** ( int ): option to select the state reordering algorithm </span>
<span class="sd">                Available options:</span>
<span class="sd">                    - 1: older version developed by Kosuke Sato, may not the working all the times</span>
<span class="sd">                    - 2: Munkres-Kuhn (Hungarian) method [default]</span>

<span class="sd">            * **params[&quot;state_reordering_alpha&quot;]** ( double ): a parameter that controls how </span>
<span class="sd">                many states will be included in the reordering</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: but changes the input St object</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;do_state_reordering&quot;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">:</span><span class="mf">0.0</span> <span class="p">}</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>

    <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">St</span><span class="p">)</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># division by 2 because it is a super-matrix</span>

    <span class="n">alp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">))</span>
    <span class="n">bet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nstates</span><span class="p">))</span>

    <span class="c1"># Initialize the cumulative permutation as the identity permutation</span>
    <span class="n">perm_cum_aa</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span> <span class="c1"># cumulative permutation for alpha spatial orbitals</span>
    <span class="n">perm_cum_bb</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span> <span class="c1"># cumulative permutation for beta  spatial orbtials</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">perm_cum_aa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">perm_cum_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># Current permutation</span>
    <span class="n">perm_t_aa</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span> 
    <span class="n">perm_t_bb</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">perm_t_aa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">perm_t_bb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>


    <span class="c1"># Temporary matrices for the Hungarian method</span>
    <span class="n">aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">);</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>
    <span class="n">ba</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">);</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>

    <span class="n">en_mat_aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">);</span> 
    <span class="n">en_mat_bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>


    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            A simple approach based on permuations - but this is not robust</span>
<span class="sd">            may have loops</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">perm_t</span> <span class="o">=</span> <span class="n">get_reordering</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># apply the cumulative permutation  </span>
            <span class="n">update_permutation</span><span class="p">(</span><span class="n">perm_t</span><span class="p">,</span> <span class="n">perm_cum</span><span class="p">)</span>

            <span class="c1"># apply the permutation</span>
            <span class="c1"># Because St = &lt;psi(t)|psi(t+dt)&gt; - we permute only columns</span>
            <span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>

            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>
            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>


        <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The Hungarian approach</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span> <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
            <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span> <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>

            <span class="c1"># Extract the alpha and beta orbtial energies</span>
            <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">en_mat_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span> <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">en_mat_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>

            <span class="c1"># Permute rows </span>
            <span class="n">aa</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_t_aa</span><span class="p">);</span>   <span class="n">ab</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_t_aa</span><span class="p">)</span>
            <span class="n">ba</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_t_bb</span><span class="p">);</span>   <span class="n">bb</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_t_bb</span><span class="p">)</span>


            <span class="c1"># compute the cost matrices for diagonal blocks</span>
            <span class="n">cost_mat_aa</span> <span class="o">=</span> <span class="n">make_cost_mat</span><span class="p">(</span><span class="n">aa</span><span class="p">,</span> <span class="n">en_mat_aa</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">])</span>
            <span class="n">cost_mat_bb</span> <span class="o">=</span> <span class="n">make_cost_mat</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="n">en_mat_bb</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">])</span>          

            <span class="c1"># Solve the optimal assignment problem for diagonal blocks</span>
            <span class="n">res_aa</span> <span class="o">=</span> <span class="n">hungarian</span><span class="o">.</span><span class="n">maximize</span><span class="p">(</span><span class="n">cost_mat_aa</span><span class="p">)</span>
            <span class="n">res_bb</span> <span class="o">=</span> <span class="n">hungarian</span><span class="o">.</span><span class="n">maximize</span><span class="p">(</span><span class="n">cost_mat_bb</span><span class="p">)</span>
   

            <span class="c1"># Convert the list of lists into the permutation object</span>
            <span class="k">for</span> <span class="n">ra</span> <span class="ow">in</span> <span class="n">res_aa</span><span class="p">:</span>
                <span class="n">perm_t_aa</span><span class="p">[</span><span class="n">ra</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">ra</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># for &lt; alpha | alpha &gt; this becomes a new value: perm_t = P_{n+1}</span>
            <span class="k">for</span> <span class="n">rb</span> <span class="ow">in</span> <span class="n">res_bb</span><span class="p">:</span>
                <span class="n">perm_t_bb</span><span class="p">[</span><span class="n">rb</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">rb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># for &lt; beta | beta &gt; this becomes a new value: perm_t = P_{n+1}   </span>

            <span class="c1"># Permute the blocks by col</span>
            <span class="n">aa</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_t_aa</span><span class="p">);</span>  <span class="n">ab</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_t_bb</span><span class="p">)</span>
            <span class="n">ba</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_t_aa</span><span class="p">);</span>  <span class="n">bb</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_t_bb</span><span class="p">)</span>

            <span class="c1"># Reconstruct St matrix </span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span> <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span> <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span></div>




<div class="viewcode-block" id="do_phase_corr"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.do_phase_corr">[docs]</a><span class="k">def</span> <span class="nf">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase1</span><span class="p">,</span> <span class="n">St</span><span class="p">,</span> <span class="n">cum_phase2</span><span class="p">,</span> <span class="n">phase_i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    This function changes the St matrix according to</span>
<span class="sd">    the previous cumulative phases and the current </span>
<span class="sd">    phase correction as:</span>

<span class="sd">    St = &lt;bra|ket&gt;</span>

<span class="sd">    St -&gt; St = F_n * St * (F_{n+1})^+ = F_n * St * (F_{n})^+ * (f_{n+1})^+</span>

<span class="sd">    Args:</span>
<span class="sd">        cum_phase1 ( CMATRIX(nstates, 1) ): cumulative phase corrections up to step n (F_n) for bra-vectors</span>
<span class="sd">        St         ( CMATRIX(nstates, nstates) ): input/output TDM to be processed: </span>
<span class="sd">            could be alpha-alpha, beta-beta, alpha-beta, or beta-alpha sub-blocks</span>
<span class="sd">        cum_phase2 ( CMATRIX(nstates, 1) ): cumulative phase corrections up to step n (F_n) for ket-vectors</span>
<span class="sd">        phase_i    ( CMATRIX(nstates, 1) ): the current step phase corrections (f_{n+1}) for a given pair of vectors</span>


<span class="sd">    Returns: </span>
<span class="sd">        None: but changes the input matrix St</span>
<span class="sd">  </span>
<span class="sd">    &quot;&quot;&quot;</span>
   
    <span class="n">nstates</span> <span class="o">=</span> <span class="n">St</span><span class="o">.</span><span class="n">num_of_rows</span>

    <span class="c1">### Correct the TDM matrix ###</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
            <span class="n">fab</span> <span class="o">=</span> <span class="n">cum_phase1</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">cum_phase2</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span> <span class="o">*</span> <span class="n">phase_i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
            <span class="n">St</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">fab</span><span class="p">)</span></div>



<div class="viewcode-block" id="apply_phase_correction"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.apply_phase_correction">[docs]</a><span class="k">def</span> <span class="nf">apply_phase_correction</span><span class="p">(</span><span class="n">St</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Performs the phase correction according to:         </span>
<span class="sd">    Akimov, A. V. J. Phys. Chem. Lett, 2018, 9, 6096</span>

<span class="sd">    Args:</span>
<span class="sd">        St ( list of CMATRIX(N,N) ): St_ij[n] = &lt;i(n)|j(n+1)&gt; transition density matrix for </span>
<span class="sd">            the timestep n, where N is the number of spin-orbitals in the active space. </span>
<span class="sd">            Spin-orbitals, not just orbitals! So it is composed as:</span>

<span class="sd">            .. math::</span>
<span class="sd">                St = </span>
<span class="sd">                \\begin{vmatrix}</span>
<span class="sd">                St_{aa}  &amp; St_{ab} \\\</span>
<span class="sd">                St_{ba}  &amp; St_{bb}</span>
<span class="sd">                \\end{vmatrix}</span>

<span class="sd">    Returns: </span>
<span class="sd">        None: but changes the input St matrices</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">St</span><span class="p">)</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># division by 2 because it is a super-matrix</span>

    <span class="n">alp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">))</span>
    <span class="n">bet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">nstates</span><span class="p">))</span>

    <span class="c1">### Initiate the cumulative phase correction factors ###    </span>
    <span class="n">cum_phase_aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># F(n-1)  cumulative phase</span>
    <span class="n">cum_phase_bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># F(n-1)  cumulative phase</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">cum_phase_aa</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">+</span><span class="mf">0.0</span><span class="n">j</span><span class="p">)</span>
        <span class="n">cum_phase_bb</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">+</span><span class="mf">0.0</span><span class="n">j</span><span class="p">)</span>


    <span class="n">St_aa</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">);</span> <span class="n">St_ab</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>
    <span class="n">St_ba</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">);</span> <span class="n">St_bb</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates</span><span class="p">,</span> <span class="n">nstates</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">):</span>

        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
        <span class="n">pop_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>

        <span class="c1">### Compute the instantaneous phase correction factors for diag. blocks ###</span>
        <span class="n">phase_i_aa</span> <span class="o">=</span> <span class="n">compute_phase_corrections</span><span class="p">(</span><span class="n">St_aa</span><span class="p">)</span>   <span class="c1"># f(i)</span>
        <span class="n">phase_i_bb</span> <span class="o">=</span> <span class="n">compute_phase_corrections</span><span class="p">(</span><span class="n">St_bb</span><span class="p">)</span>   <span class="c1"># f(i)       </span>

        <span class="c1">### Do the  phase correstions for the diag. blocks ###</span>
        <span class="n">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase_aa</span><span class="p">,</span> <span class="n">St_aa</span><span class="p">,</span> <span class="n">cum_phase_aa</span><span class="p">,</span> <span class="n">phase_i_aa</span><span class="p">)</span>
        <span class="n">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase_bb</span><span class="p">,</span> <span class="n">St_bb</span><span class="p">,</span> <span class="n">cum_phase_bb</span><span class="p">,</span> <span class="n">phase_i_bb</span><span class="p">)</span>
        
        <span class="c1">### Do the  phase correstions for the off-diag. blocks ###</span>
        <span class="n">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase_aa</span><span class="p">,</span> <span class="n">St_ab</span><span class="p">,</span> <span class="n">cum_phase_bb</span><span class="p">,</span> <span class="n">phase_i_bb</span><span class="p">)</span>
        <span class="n">do_phase_corr</span><span class="p">(</span><span class="n">cum_phase_bb</span><span class="p">,</span> <span class="n">St_ba</span><span class="p">,</span> <span class="n">cum_phase_aa</span><span class="p">,</span> <span class="n">phase_i_aa</span><span class="p">)</span>

        <span class="c1">### Push the corrected diag. blocks to orig. St matrix ###</span>
        <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_aa</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>   <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ab</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
        <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_ba</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">);</span>   <span class="n">push_submatrix</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">St_bb</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>

        <span class="c1">### Update the cumulative phase correction factors for diag. blocks ###</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
            <span class="n">cum_phase_aa</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">phase_i_aa</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="n">cum_phase_bb</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">phase_i_bb</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">))</span></div>




<div class="viewcode-block" id="sac_matrices"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.sac_matrices">[docs]</a><span class="k">def</span> <span class="nf">sac_matrices</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">S_ks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function makes the Phi-to-Chi (P2C) transformation matrix.</span>
<span class="sd">    Normalization factros for the Chi states are computed based on the </span>
<span class="sd">    overlaps of Phi states.</span>
<span class="sd">    &lt; Chi_i | Chi_j &gt; = 1</span>
<span class="sd">    = N_i * N_j * &lt; Phi_i - Phi_i&#39; | Phi_j - Phi_j&#39; &gt; = 1</span>

<span class="sd">    coeff [List of lists] - P2C as initialized by the user</span>
<span class="sd">    basis [Phi basis] - as initialized by the user </span>
<span class="sd">    S_ks  [CMATRIX] - Time overlap matrix of elementary KS orbtials, from step2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_chi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
    <span class="n">n_phi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">P2C</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">n_phi</span><span class="p">,</span> <span class="n">n_chi</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_chi</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_phi</span><span class="p">):</span>
            <span class="n">P2C</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">coeff</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">0.0</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># Compute the overlaps of the SDs:</span>
    <span class="c1">#</span>
    <span class="n">Ssd</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">ovlp_mat_arb</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">S_ks</span><span class="p">)</span>

    <span class="c1"># Normalize the Chi wavefunctions #</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">P2C</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">Ssd</span> <span class="o">*</span> <span class="n">P2C</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n_chi</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">norm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">P2C</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">))</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in CHI normalizaiton: some combination gives zero norm</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">P2C</span></div>


<div class="viewcode-block" id="scale_H_vib"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.scale_H_vib">[docs]</a><span class="k">def</span> <span class="nf">scale_H_vib</span><span class="p">(</span><span class="n">hvib</span><span class="p">,</span> <span class="n">en_gap</span><span class="p">,</span> <span class="n">dNAC</span><span class="p">,</span> <span class="n">sc_nac_method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function scales the energies and NACs in the vibrionic Hamiltonian</span>
<span class="sd">    in the Chi basis. </span>

<span class="sd">    Args:   </span>
<span class="sd">        hvib ( list of CMATRIX objects ): </span>
<span class="sd">            CMATRIXlist of vibronic hamiltonians in the Chi basis</span>
<span class="sd">        en_gap ( float ): The desired energy gap (E_1 - E_0), for the Chi basis</span>
<span class="sd">        dNAC ( list of lists of (list, float) ):</span>
<span class="sd">            The scaling terms by which specific nacs will </span>
<span class="sd">            be scaled datatype = list of lists of (list, float)</span>

<span class="sd">            [  [ [i,j], val ], ...  ]          </span>

<span class="sd">            n and n+1 are the col (and thereby row) indicies of </span>
<span class="sd">            the nacs to be scaled by the value val </span>
<span class="sd">        sc_nac_method ( int ): The method used to scale NACs in the Chi basis, </span>
<span class="sd">            chosen by the user.</span>
<span class="sd">            If sc_nac_method = 1, then the NACs are scaled by the ivnerse of the</span>
<span class="sd">            magnitude of the change in energy, according to Lin et al.</span>

<span class="sd">            Reference: Lin, Y. &amp; Akimov, A. V. J. Phys. Chem. A (2016) </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">traj_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hvib</span><span class="p">)</span>

    <span class="c1"># Do the scaling</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">hvib</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_rows</span>
    <span class="n">ncols</span> <span class="o">=</span> <span class="n">hvib</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span>   
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">traj_len</span><span class="p">):</span>

        <span class="n">prev_gap</span> <span class="o">=</span> <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">en_gap</span> <span class="o">-</span> <span class="n">prev_gap</span> 

        <span class="c1"># Scale the energy gap, by adding the scaling factors to all excited states</span>
        <span class="c1"># This is to keep the ground state enegy equal to 0.0 by definition</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ncols</span><span class="p">):</span>
            <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sc_nac_method</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># Scales nacs manually as set by user</span>
            <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">dNAC</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="o">=</span> <span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">it</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">it</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">sc_nac_method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Scales nacs by the inverse of the change in energy gap</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ncols</span><span class="p">):</span>
                <span class="n">scl_nac</span> <span class="o">=</span> <span class="n">prev_gap</span> <span class="o">/</span> <span class="p">(</span><span class="n">shift</span> <span class="o">+</span> <span class="n">prev_gap</span><span class="p">)</span>
                <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">scl_nac</span><span class="p">)</span>
                <span class="n">hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scl_nac</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hvib</span>                    </div>


<div class="viewcode-block" id="compute_Hvib"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.compute_Hvib">[docs]</a><span class="k">def</span> <span class="nf">compute_Hvib</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">St_ks</span><span class="p">,</span> <span class="n">E_ks</span><span class="p">,</span> <span class="n">dE</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the vibronic Hamiltonian matrix</span>
<span class="sd">    </span>
<span class="sd">    Args:    </span>
<span class="sd">        basis ( list of lists of integers ): defines the basis of Slater Determinants, </span>
<span class="sd">            such that: basis[iSD][iks] is the indicator of the spin-orbital occupied by </span>
<span class="sd">            the electron iks in the Slater Determinant iSD</span>

<span class="sd">            Example: </span>

<span class="sd">                The following example defines a ground state SD (the lowest KS of the active space) and two </span>
<span class="sd">                single excitations, which are different from each other by two spin flips of the electrons</span>
<span class="sd">                The convention is to start indexing from 1 (corresponds to index 0 in the KS matrices)</span>
<span class="sd">                Positive - for alpha electrons, negative - for beta electrons</span>
<span class="sd">                Need to be consistent: [ -1, 2 ] and [ 2, -1 ] are treated differently, this is needed for spin-adaptation</span>

<span class="sd">                &gt;&gt; basis = [ [ 1,-1 ], [ 1,-2 ], [ 2,-1 ] ]</span>

<span class="sd">                The next example is for a system of 4 electrons and hole excitations</span>
<span class="sd">                &gt;&gt; basis = [ [ 1,-1, 2, -2 ], [ 3, -1, 2, -2 ], [ 1, -3, 2, -2 ] ]</span>

<span class="sd">                                                                       </span>
<span class="sd">        St_ks ( CMATRIX(2*norbs, 2*norbs) ): transition density matrix in the KS spin-orbitals basis, where </span>
<span class="sd">            norb - the number of double-occupied orbitals.</span>

<span class="sd">        E_ks ( CMATRIX(2*norbs, 2*norbs) ): the orbital energies in the KS spin-orbitals basis, where </span>
<span class="sd">            norb - the number of double-occupied orbitals.</span>

<span class="sd">        dE ( list of doubles ): define corrections of the SD state energies in comparison to </span>
<span class="sd">            the energy give by the sum energies of the occupied spin-orbitals.</span>
<span class="sd">            The convention is: dE[iSD] is the correction to energy of the SD with index iSD. </span>
<span class="sd">            This is a constant correction - same for all energies in the set [units: Ha] </span>

<span class="sd">            Example:</span>
<span class="sd">                For instance, for the SD examples above, the corrections could be:</span>
<span class="sd">                &gt;&gt; dE = [0.0, 0.01, 0.05]</span>

<span class="sd">        dt ( double ): the timestep for MD integrations [units: a.u.]</span>

<span class="sd">    Returns: </span>
<span class="sd">        CMATRIX(nstates, nstates) The Vibronic Hamiltonian</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">St</span>    <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">ovlp_mat_arb</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">St_ks</span><span class="p">)</span> 
    <span class="n">H_el</span>  <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">energy_mat_arb</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">E_ks</span><span class="p">,</span> <span class="n">dE</span><span class="p">)</span>
    <span class="n">H_vib</span> <span class="o">=</span> <span class="n">H_el</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span><span class="n">j</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">CMATRIX</span><span class="p">((</span><span class="n">St</span><span class="o">-</span><span class="n">St</span><span class="o">.</span><span class="n">H</span><span class="p">())</span><span class="o">.</span><span class="n">real</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">H_vib</span></div>




<div class="viewcode-block" id="run"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.run">[docs]</a><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">S_dia_ks</span><span class="p">,</span> <span class="n">St_dia_ks</span><span class="p">,</span> <span class="n">E_dia_ks</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The procedure to converts the results of QE calculations (KS orbital energies and</span>
<span class="sd">    time-overlaps = transition density matrices in the KS basis) to the generic Hvib matrices, </span>
<span class="sd">    which (optionally) account for:   </span>

<span class="sd">    - enforces orthogonalization of the input KS states</span>
<span class="sd">    - state reordering</span>
<span class="sd">    - phase corrections</span>
<span class="sd">    - multi-electron wavefunction (Slater determinants) and spin-adaptation</span>

<span class="sd">    Args:</span>
<span class="sd">        S_dia_ks ( list of lists of CMATRIX objects ): overlaps of the KS orbitals along trajectories</span>
<span class="sd">            for each data set. Such that S_dia_ks[idata][istep].get(i,j) is &lt;i(istep)|j(istep)&gt; for the </span>
<span class="sd">            trajectory (=dataset) ```idata```.</span>

<span class="sd">        St_dia_ks ( list of lists of CMATRIX objects ): time-overlaps (=transition density matrices) </span>
<span class="sd">            in the basis of the KS orbitals along trajectories for each data set. </span>
<span class="sd">            Such that St_dia_ks[idata][istep].get(i,j) is &lt;i(istep)|j(istep+1)&gt; for the trajectory (=dataset) ```idata```.</span>

<span class="sd">        E_dia_ks ( list of lists of CMATRIX objects ): energies the KS orbitals at the mid-points along trajectories</span>
<span class="sd">            for each data set. Such that E_dia_ks[idata][istep].get(i,i) is 0.5*(E_i(istep) + E_i(istep+1)) for the </span>
<span class="sd">            trajectory (=dataset) ```idata```</span>

<span class="sd">        params ( dictionary ): Control paramerter of this type of simulation. Can include the follwing keys:</span>

<span class="sd">            * **params[&quot;SD_basis&quot;]** ( list of lists of ints ): define the Slater Determinants basis</span>
<span class="sd">                The convention is:  params[&quot;SD_basis&quot;][iSD][iks] is the indicator of the spin-orbital occupied by </span>
<span class="sd">                the electron iks in the Slater Determinant iSD [required!]</span>

<span class="sd">                Example: </span>

<span class="sd">                    The following example defines a ground state SD (the lowest KS of the active space) and two </span>
<span class="sd">                    single excitations, which are different from each other by two spin flips of the electrons</span>
<span class="sd">                    The convention is to start indexing from 1 (corresponds to index 0 in the KS matrices)</span>
<span class="sd">                    Positive - for alpha electrons, negative - for beta electrons</span>
<span class="sd">                    Need to be consistent: [ -1, 2 ] and [ 2, -1 ] are treated differently, this is needed for spin-adaptation</span>

<span class="sd">                    &gt;&gt; params[&quot;SD_basis&quot;] = [ [ 1,-1 ], [ 1,-2 ], [ 2,-1 ] ]</span>

<span class="sd">                    The next example is for a system of 4 electrons and hole excitations</span>
<span class="sd">                    &gt;&gt; params[&quot;SD_basis&quot;] = [ [ 1,-1, 2, -2 ], [ 3, -1, 2, -2 ], [ 1, -3, 2, -2 ] ]</span>


<span class="sd">            * **params[&quot;SD_energy_corr&quot;]** ( list of doubles ): define corrections of the SD state energies in comparison to </span>
<span class="sd">                the energy give by the sum energies of the occupied spin-orbitals.</span>
<span class="sd">                The convention is: params[&quot;SD_energy_corr&quot;][iSD] is the correction to energy of the SD with index iSD. </span>
<span class="sd">                This is a constant correction - same for all energies in the set [units: Ha] [required!]</span>

<span class="sd">                Example:</span>
<span class="sd">                    For instance, for the SD examples above, the corrections could be:</span>
<span class="sd">                    &gt;&gt; params[&quot;SD&quot;] = [0.0, 0.01, 0.05]</span>
<span class="sd">                                     </span>
<span class="sd">            * **params[&quot;CI_basis&quot;]** ( list of lists of complex number ): configuration interaction coefficients </span>
<span class="sd">                that define a superpositions to SDs that are considered the states of interest, e.g. spin-adapted configurations</span>
<span class="sd">                The convention is: params[&quot;CI_basis&quot;][iCI][iSD] is a coefficient of ```iSD```-th SD in the expansion of the CI</span>
<span class="sd">                with index ```iCI```. These coefficients don&#39;t have to account for the overal CI&#39;s normalization - the </span>
<span class="sd">                normalization will be done on the go. [required!]</span>

<span class="sd">                Example:</span>

<span class="sd">                    For the SD example above we can construct the following combinations:</span>
<span class="sd">                    &gt;&gt; params[&quot;CI_basis&quot;] = [ [1.0, 0.0, 0.0 ], </span>
<span class="sd">                                              [0.0, 1.0,-1.0 ],</span>
<span class="sd">                                              [0.0, 1.0, 1.0 ] </span>
<span class="sd">                                            ]</span>

<span class="sd">            * **params[&quot;output_set_paths&quot;]** ( list of strings ): the directory pathes where the resulting files </span>
<span class="sd">                are to be written (if so!). If you don&#39;t plan on writing the files, just provide a list of empty strings</span>
<span class="sd">                or whatever else - they will not be used in that case. The number of the strings should be equal to </span>
<span class="sd">                the number of the input data sets, e.g. to len(St_dia_ks)  [required!]</span>

<span class="sd">                  </span>
<span class="sd">            * **params[&quot;dt&quot;]** ( double ): nuclear dynamics integration time step [units: a.u. of time, default: 41.0]</span>
<span class="sd"> </span>
<span class="sd">            * **params[&quot;do_orthogonalization&quot;]** ( int ): the option to do Lowdin orthogonalization of the orbitals - using </span>
<span class="sd">                the &quot;raw&quot; overlaps (at the same time). This option is needed because the wavefunction output by QE are </span>
<span class="sd">                not exactly orthonormal (because of the use of pseudopotentials). So before we use them (implicitly) </span>
<span class="sd">                in the rest of the calculations here, we may need to account for this non-ideality effect.</span>
<span class="sd">                Options:</span>
<span class="sd">        </span>
<span class="sd">                - 0: don&#39;t do the orthogonalization - this is the same as in Pyxaid [default]</span>
<span class="sd">                - 1: do the orthogonalization</span>

<span class="sd">            * **params[&quot;do_state_reordering&quot;]** ( int ): the option to control the state reordering</span>
<span class="sd">                Options:</span>

<span class="sd">                - 0: no state reordering - same as in Pyxaid</span>
<span class="sd">                - 1: older method (is not robust, may or may not work) </span>
<span class="sd">                - 2: Hungarian algorithm [default]</span>

<span class="sd">            * **params[&quot;state_reordering_alpha&quot;]** ( double ): the parameter that controls the width of </span>
<span class="sd">                the energy interval within wich the state reordering is in effect. Zero value means all </span>
<span class="sd">                available orbitals, larger positive value decreases the width of the window. This parameter</span>
<span class="sd">                is not in effect unless the Hungarian algorithm is selected [default: 0.0]</span>

<span class="sd">            * **params[&quot;do_phase_correction&quot;]** ( int ): option to do the phase correction</span>

<span class="sd">                - 0 - don&#39;t do </span>
<span class="sd">                - 1 - do it [default]</span>

<span class="sd">            * **params[&quot;do_output&quot;]** ( int ): whether to print out the Hvib matrices ( = 1) to the files or not ( = 0).</span>

<span class="sd">            * **params[&quot;Hvib_re_prefix&quot;]** ( string ): common prefix of the output files with real part of the vibronic </span>
<span class="sd">                Hamiltonian at all times [default: &quot;Hvib_&quot;]</span>

<span class="sd">            * **params[&quot;Hvib_re_suffix&quot;]** ( string ): common suffix of the output files with real part of the vibronic </span>
<span class="sd">                Hamiltonian at all times [default: &quot;_re&quot;]</span>

<span class="sd">            * **params[&quot;Hvib_im_prefix&quot;]** ( string ): common prefix of the output files with imaginary part of the vibronic </span>
<span class="sd">                Hamiltonian at all times [default: &quot;Hvib_&quot;]</span>

<span class="sd">            * **params[&quot;Hvib_im_suffix&quot;]** ( string ): common suffix of the output files with imaginary part of the vibronic </span>
<span class="sd">                Hamiltonian at all times [default: &quot;_im&quot;]</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of lists of CMATRIX(N,N): Hvib, such that:</span>
<span class="sd">            Hvib[idata][istep] is a CMATRIX(N,N) containing the vibronic Hamiltonian for the </span>
<span class="sd">            trajectory (dataset) ```idata``` and for the timestep ```istep```. Here, N is the number</span>
<span class="sd">            of states included in the active space.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1">#====== Defaults and local parameters ===============</span>

    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;SD_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;SD_energy_corr&quot;</span><span class="p">,</span> <span class="s2">&quot;CI_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;output_set_paths&quot;</span> <span class="p">]</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;dt&quot;</span><span class="p">:</span><span class="mf">1.0</span><span class="o">*</span><span class="n">units</span><span class="o">.</span><span class="n">fs2au</span><span class="p">,</span> 
                       <span class="s2">&quot;do_orthogonalization&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                       <span class="s2">&quot;do_state_reordering&quot;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span>
                       <span class="s2">&quot;do_phase_correction&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
                       <span class="s2">&quot;do_output&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                       <span class="s2">&quot;Hvib_re_prefix&quot;</span><span class="p">:</span><span class="s2">&quot;Hvib_&quot;</span><span class="p">,</span> <span class="s2">&quot;Hvib_im_prefix&quot;</span><span class="p">:</span><span class="s2">&quot;Hvib_&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Hvib_re_suffix&quot;</span><span class="p">:</span><span class="s2">&quot;_re&quot;</span><span class="p">,</span> <span class="s2">&quot;Hvib_im_suffix&quot;</span><span class="p">:</span><span class="s2">&quot;_im&quot;</span><span class="p">,</span>

                     <span class="p">}</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>
 
    <span class="n">dt</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span>
    <span class="n">do_orthogonalization</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_orthogonalization&quot;</span><span class="p">]</span>
    <span class="n">do_phase_correction</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_phase_correction&quot;</span><span class="p">]</span>
    <span class="n">do_state_reordering</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]</span>
    <span class="n">ndata</span> <span class="o">=</span>  <span class="nb">len</span><span class="p">(</span><span class="n">St_dia_ks</span><span class="p">)</span>
    <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">St_dia_ks</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;CI_basis&quot;</span><span class="p">])</span>  <span class="c1"># the number of CI states to consider</span>

    <span class="n">do_output</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_output&quot;</span><span class="p">]</span>

    <span class="c1">#====== Generic sanity checks ===============</span>
    <span class="k">if</span> <span class="n">do_output</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ndata</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: The number of output sets paths should be the same as the number of data sets</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ndata = &quot;</span><span class="p">,</span> <span class="n">ndata</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(params[</span><span class="se">\&quot;</span><span class="s2">output_set_paths</span><span class="se">\&quot;</span><span class="s2">]) = &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">]))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exiting...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



    <span class="c1">#====== Calculations  ===============</span>
    <span class="n">H_vib</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idata</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ndata</span><span class="p">):</span>

        <span class="c1"># 1. Do the KS orbitals orthogonalization </span>
        <span class="k">if</span> <span class="n">do_orthogonalization</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">apply_normalization</span><span class="p">(</span><span class="n">S_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">],</span> <span class="n">St_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">])</span>

        <span class="c1"># 2. Apply state reordering to KS</span>
        <span class="k">if</span> <span class="n">do_state_reordering</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">apply_state_reordering</span><span class="p">(</span><span class="n">St_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">],</span> <span class="n">E_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">],</span> <span class="n">params</span><span class="p">)</span>

        <span class="c1"># 3. Apply phase correction to KS</span>
        <span class="k">if</span> <span class="n">do_phase_correction</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">apply_phase_correction</span><span class="p">(</span><span class="n">St_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">])</span>
       
        
        <span class="n">Hvib</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nsteps</span><span class="p">):</span>
        
            <span class="c1"># 4. Construct the Hvib in the basis of Slater determinants (SDs)</span>
            <span class="n">hvib_sd</span> <span class="o">=</span> <span class="n">compute_Hvib</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_basis&quot;</span><span class="p">],</span> <span class="n">St_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">E_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_energy_corr&quot;</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span> 
      
            <span class="c1"># 5. Convert the Hvib to the basis of symmery-adapted configurations (SAC)</span>
            <span class="n">SD2CI</span> <span class="o">=</span> <span class="n">sac_matrices</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;CI_basis&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_basis&quot;</span><span class="p">],</span> <span class="n">S_dia_ks</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">hvib_ci</span> <span class="o">=</span> <span class="n">SD2CI</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">hvib_sd</span> <span class="o">*</span> <span class="n">SD2CI</span>
            <span class="n">Hvib</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">hvib_ci</span> <span class="p">)</span>


        <span class="k">if</span> <span class="n">do_output</span><span class="p">:</span>
            <span class="c1"># Output the resulting Hamiltonians</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nsteps</span><span class="p">):</span>
                <span class="n">re_filename</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">][</span><span class="n">idata</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_re_prefix&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_re_suffix&quot;</span><span class="p">]</span>
                <span class="n">im_filename</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">][</span><span class="n">idata</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_im_prefix&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_im_suffix&quot;</span><span class="p">]</span>        
                <span class="n">Hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="n">re_filename</span><span class="p">)</span>
                <span class="n">Hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="n">im_filename</span><span class="p">)</span>


        <span class="n">H_vib</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Hvib</span><span class="p">)</span>        
        
    <span class="k">return</span> <span class="n">H_vib</span></div>




<span class="k">def</span> <span class="nf">map_Hvib</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">dE</span><span class="p">):</span>

    <span class="n">nbasis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># doesn&#39;t matter</span>

    <span class="n">H_vib</span>  <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">energy_mat_arb</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">dE</span><span class="p">)</span>

    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">delta</span><span class="p">(</span><span class="n">Py2Cpp_int</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">Py2Cpp_int</span><span class="p">(</span><span class="n">basis</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">)</span>

            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">sd2indx</span><span class="p">([</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">nbasis</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> 
                    <span class="n">H_vib</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">H_vib</span>



<div class="viewcode-block" id="pyxaid2libra"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step3.html#libra_py.workflows.nbra.step3.pyxaid2libra">[docs]</a><span class="k">def</span> <span class="nf">pyxaid2libra</span><span class="p">(</span><span class="n">Hvib_pyxaid</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#====== Defaults and local parameters ===============</span>

    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;SD_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;SD_energy_corr&quot;</span><span class="p">,</span> <span class="s2">&quot;CI_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;output_set_paths&quot;</span> <span class="p">]</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;do_output&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                       <span class="s2">&quot;Hvib_re_prefix&quot;</span><span class="p">:</span><span class="s2">&quot;Hvib_&quot;</span><span class="p">,</span> <span class="s2">&quot;Hvib_im_prefix&quot;</span><span class="p">:</span><span class="s2">&quot;Hvib_&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;Hvib_re_suffix&quot;</span><span class="p">:</span><span class="s2">&quot;_re&quot;</span><span class="p">,</span> <span class="s2">&quot;Hvib_im_suffix&quot;</span><span class="p">:</span><span class="s2">&quot;_im&quot;</span><span class="p">,</span>
                     <span class="p">}</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>

      
    <span class="n">ndata</span> <span class="o">=</span>  <span class="nb">len</span><span class="p">(</span><span class="n">Hvib_pyxaid</span><span class="p">)</span>
    <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">norbs</span> <span class="o">=</span> <span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;CI_basis&quot;</span><span class="p">])</span>  <span class="c1"># the number of CI states to consider</span>
    <span class="n">do_output</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_output&quot;</span><span class="p">]</span>


    <span class="n">S</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">norbs</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">norbs</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">norbs</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">norbs</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">CMATRIX</span><span class="p">(</span><span class="n">norbs</span><span class="p">,</span> <span class="n">norbs</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">identity</span><span class="p">()</span>
    <span class="n">alp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">norbs</span><span class="p">))</span>
    <span class="n">bet</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">norbs</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">norbs</span><span class="p">))</span>

    <span class="n">push_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
    <span class="n">push_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
    <span class="n">push_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
    <span class="n">push_submatrix</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>

    <span class="c1">#====== Generic sanity checks ===============</span>
    <span class="k">if</span> <span class="n">do_output</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">ndata</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">]):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: The number of output sets paths should be the same as the number of data sets</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ndata = &quot;</span><span class="p">,</span> <span class="n">ndata</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;len(params[</span><span class="se">\&quot;</span><span class="s2">output_set_paths</span><span class="se">\&quot;</span><span class="s2">]) = &quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">])</span> <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Exiting...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>



    <span class="c1">#====== Calculations  ===============</span>
    <span class="n">H_vib</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">idata</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ndata</span><span class="p">):</span>

        <span class="n">Hvib</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nsteps</span><span class="p">):</span>
        
            <span class="c1"># 1. Construct the Hvib in the basis of Slater determinants (SDs)            </span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">alp</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">alp</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">bet</span><span class="p">,</span> <span class="n">alp</span><span class="p">)</span>
            <span class="n">push_submatrix</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">Hvib_pyxaid</span><span class="p">[</span><span class="n">idata</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">bet</span><span class="p">,</span> <span class="n">bet</span><span class="p">)</span>
            <span class="n">hvib_sd</span> <span class="o">=</span> <span class="n">map_Hvib</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_basis&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_energy_corr&quot;</span><span class="p">])</span> 
      
            <span class="c1"># 2. Convert the Hvib to the basis of symmery-adapted configurations (SAC)</span>
            <span class="n">SD2CI</span> <span class="o">=</span> <span class="n">sac_matrices</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;CI_basis&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;SD_basis&quot;</span><span class="p">],</span> <span class="n">S</span><span class="p">)</span>
            <span class="n">hvib_ci</span> <span class="o">=</span> <span class="n">SD2CI</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">hvib_sd</span> <span class="o">*</span> <span class="n">SD2CI</span>
            <span class="n">Hvib</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">hvib_ci</span> <span class="p">)</span>


        <span class="k">if</span> <span class="n">do_output</span><span class="p">:</span>
            <span class="c1"># Output the resulting Hamiltonians</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nsteps</span><span class="p">):</span>
                <span class="n">re_filename</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">][</span><span class="n">idata</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_re_prefix&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_re_suffix&quot;</span><span class="p">]</span>
                <span class="n">im_filename</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;output_set_paths&quot;</span><span class="p">][</span><span class="n">idata</span><span class="p">]</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_im_prefix&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;Hvib_im_suffix&quot;</span><span class="p">]</span>        
                <span class="n">Hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="n">re_filename</span><span class="p">)</span>
                <span class="n">Hvib</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="n">im_filename</span><span class="p">)</span>

        <span class="n">H_vib</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Hvib</span><span class="p">)</span>        
        
    <span class="k">return</span> <span class="n">H_vib</span></div>



</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Alexey V. Akimov

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>